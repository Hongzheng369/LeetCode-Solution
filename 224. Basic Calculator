class Solution {
    public int calculate(String s) {
        return method1(s);
        //return method2(s);
        //return method3(s);
    }
    
    /////////////////////////////////////////////////////////////////////////////////////
    /**
     * Method 1: standard method for calculating an expression in string. 
     * One stack is for saving integer,
     * ... other one is for saving operators.
     */
    private int method1(String s) {
        Stack<Integer> nums = new Stack<>();
        Stack<Character> ops = new Stack<>();
        int len = s.length();
        
        for (int i = 0; i < len; i++) {
            char c = s.charAt(i);
            
            if (c == ' ') {
                continue;
            } else if (Character.isDigit(c)) {
                i = getNumberLastIndex(s, i, len, nums);
            } else if (c == '(') {
                ops.push(c);
            } else if (c == ')') {
                clearParenthesis(nums, ops);
            } else {
                if (ops.isEmpty() || ops.peek() == '(') {
                    ops.push(c);
                } else {
                    plusOrMinus(nums, ops, c);
                }
            }
        }
        
        return clearStack(nums, ops);
    }
    
    private int getNumberLastIndex(String s, int i, int len, Stack<Integer> nums) {
        int j = i + 1;
        while (j < len && Character.isDigit(s.charAt(j))) {
            j++;
        }
        nums.push(Integer.parseInt(s.substring(i, j)));
        return j - 1;
    }
    
    private void plusOrMinus(Stack<Integer> nums, Stack<Character> ops, char c) {
        char temp = ops.pop();
        int num2 = nums.pop(), num1 = nums.pop();
        if (temp == '+') {
            nums.push(num1 + num2);
        } else {
            nums.push(num1 - num2);
        }
        ops.push(c);
    }
    
    private void clearParenthesis(Stack<Integer> nums, Stack<Character> ops) {
        while (ops.peek() != '(') {
            char temp = ops.pop();
            int num2 = nums.pop(), num1 = nums.pop();
            if (temp == '+') {
                nums.push(num1 + num2);
            } else {
                nums.push(num1 - num2);
            }
        }
        ops.pop();
    }
    
    private int clearStack(Stack<Integer> nums, Stack<Character> ops) {
        while (!ops.isEmpty()) {
            char temp = ops.pop();
            int num2 = nums.pop(), num1 = nums.pop();
            if (temp == '+') {
                nums.push(num1 + num2);
            } else {
                nums.push(num1 - num2);
            }
        }
        return nums.pop();
    }
    
    /////////////////////////////////////////////////////////////////////////////////////
    /**
     * Method 2: Traverse the string from the end, and stack is used here.
     */    
    private int method2(String s)  {
        Stack<Object> stack = new Stack<>();
        int len = s.length();
        
        for (int i = len - 1; i > -1; i--) {
            char c = s.charAt(i);
            
            if (c == ' ') {
                continue;
            } else if (Character.isDigit(c)) {
                i = getNumberFirstIndex(s, i ,stack);
            } else if (c == ')' || c == '+' || c == '-') {
                stack.push(c);
            } else {
                calculateOneParenthesis(stack);
            }
        }
        
        
        return clearStack(stack);
    }
    
    private int getNumberFirstIndex(String s, int i, Stack<Object> stack) {
        int j = i - 1;
        while (j > -1 && Character.isDigit(s.charAt(j))) {
            j--;
        }
        stack.push(Integer.parseInt(s.substring(j + 1, i + 1)));
        return j + 1;
    }
    
    private void calculateOneParenthesis(Stack<Object> stack) {
        int result = (int)(stack.pop());
        
        while ((char)(stack.peek()) != ')') {
            char op = (char)(stack.pop());
            
            if (op == '+') {
                result += (int)(stack.pop());
            } else {
                result -= (int)(stack.pop());
            }
        }
        
        stack.pop();
        stack.push(result);
    }
    
    private int clearStack(Stack<Object> stack) {
        int result = (int)(stack.pop());
        
        while (!stack.isEmpty()) {
            char op = (char)(stack.pop());
            
            if (op == '+') {
                result += (int)(stack.pop());
            } else {
                result -= (int)(stack.pop());
            }
        }
        
        return result;
    }
    
    /////////////////////////////////////////////////////////////////////////////////////
    /**
     * Method 3: using stack to save the operators and numbers. This time 
     */
    private int method3(String s) {
        Stack<Integer> elements = new Stack<>();
        int num = 0, currRes = 0, sign = 1, len = s.length();
        
        for (int i = 0; i < len; i++) {
            char c = s.charAt(i);
            
            if (c == ' ') {
                continue;
            } else if (Character.isDigit(c)) {
                num = num * 10 + (c - '0');
            } else if (c == '+') {
                currRes += sign * num;                
                num = 0;
                sign = 1;
            } else if (c == '-') {
                currRes += sign * num;
                num = 0;
                sign = -1;
            } else if (c == '(') {
                elements.push(currRes);
                elements.push(sign);
                
                // reset to calculate the value in the parenthesis
                currRes = 0;
                sign = 1;
            } else {
                currRes += sign * num;
                sign = elements.pop();
                currRes = elements.pop() + sign * currRes;
                num = 0;
            }
        }
        
        return currRes + sign * num;
    }
}
