/**
 * My solution, based on Question 79 "Word Search".
 */

class Solution {
    public List<String> findWords(char[][] board, String[] words) {
		List<String> ans = new ArrayList<>();
		if (board == null || board.length == 0 || board[0].length == 0) {
        	return ans;
        }
		
        int rows = board.length, cols = board[0].length;
        for (String word : words) {
            boolean isFound = false;
            
        	for (int i = 0; i < rows; i++) {
            	for (int j = 0; j < cols; j++) {
            		if (helper(board, i, j, word, 0)) {
            			isFound = true;
                        ans.add(word);
                        break;
            		}
            	}
                
                if (isFound) {
                    break;
                }
            }
        }
        
        return ans;
    }
	
	private boolean helper(char[][] board, int i, int j, String word, int pos) {
		if (i < 0 || i > board.length - 1 || j < 0 || j > board[0].length - 1) {
			return false;
		}
		
		if (board[i][j] == word.charAt(pos)) {
			if (pos == word.length() - 1) {
				return true;
			}
			
			char temp = board[i][j];
			board[i][j] = '#';
			
			if (helper(board, i - 1, j, word, pos + 1) || 
					helper(board, i + 1, j, word, pos + 1) || 
					helper(board, i, j - 1, word, pos + 1) ||
					helper(board, i, j + 1, word, pos + 1)) {
				board[i][j] = temp;
                return true;
			}
            
            board[i][j] = temp;
		}
		
		return false;
	}
}

------------------------------------------------------------------------------------------------------------------

/**
 * A better method is using Trie. Build the words list into Trie first, 
 * ... and then traverse the board along with the "dictionary".
 */
 
 class Solution {
	private class TrieNode {
		private TrieNode[] children = new TrieNode[26];
		private String item = "";
	}
	
	private class Trie {
		private TrieNode root = new TrieNode();
		
		private void insertWord(String word) {
			TrieNode node = root;
			
			for (char c : word.toCharArray()) {
				int index = c - 'a';
				if (node.children[index] == null) {
					node.children[index] = new TrieNode();
				}
				node = node.children[index];
			}
			
			node.item = word;
		}
		
		private boolean searchWord(String word) {
			TrieNode node = root;
			
			for (char c : word.toCharArray()) {
				int index = c - 'a';
				if (node.children[index] == null) {
					return false;
				}
				node = node.children[index];
			}
			
			return node.item.equals(word);
		}
		
		private boolean isStartingWith(String prefix) {
			TrieNode node = root;
			
			for (char c : prefix.toCharArray()) {
				int index = c - 'a';
				if (node.children[index] == null) {
					return false;
				}
				node = node.children[index];
			}
			
			return true;
		}
	}
	
	public List<String> findWords(char[][] board, String[] words) {
        // save words into Trie
		Trie trie = new Trie();
		for (String word : words) {
			trie.insertWord(word);
		}
		
		// initiate
		int rows = board.length, cols = board[0].length;
		Set<String> ans = new HashSet<>();
		boolean[][] visited = new boolean[rows][cols];
		
		// DFS
		for (int i = 0; i < rows; i++) {
			for (int j = 0; j < cols; j++) {
				dfs(board, i, j, trie, visited, "", ans);
			}
		}
		
		return new ArrayList<>(ans);
    }
	
	private void dfs(char[][] board, int i, int j, Trie trie, boolean[][] visited, String prefix, Set<String> ans) {
		// base case
		if (i < 0 || j < 0 || i > board.length - 1 || j > board[0].length - 1) {
			return;
		} else if (visited[i][j]) {
			return;
		}
		
		prefix = prefix + board[i][j];
		if (!trie.isStartingWith(prefix)) {
			return;
		}
		
		if (trie.searchWord(prefix)) {
			ans.add(prefix);
		}
		visited[i][j] = true;
		dfs(board, i - 1, j, trie, visited, prefix, ans);
		dfs(board, i + 1, j, trie, visited, prefix, ans);
		dfs(board, i, j - 1, trie, visited, prefix, ans);
		dfs(board, i, j + 1, trie, visited, prefix, ans);
		visited[i][j] = false;
	}
}
