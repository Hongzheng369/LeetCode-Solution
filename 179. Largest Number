class Solution {
    // Method 1: use priority queue and new Comparator().
    /*
    public String largestNumber(int[] nums) {
        if (nums == null || nums.length == 0) {
            return "";
        }

        PriorityQueue<String> queue = new PriorityQueue<>(new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                String s1 = o1 + o2;
                String s2 = o2 + o1;
                return -s1.compareTo(s2);
            }
        });

        for (int num : nums) {
            queue.add(Integer.toString(num));
        }
        if (queue.peek().equals("0")) {
            return "0";
        }

        StringBuilder ans = new StringBuilder();
        while (!queue.isEmpty()) {
            ans.append(queue.remove());
        }

        return ans.toString();
    }*/

    // Method 2. Use array and new Comparator().

    public String largestNumber(int[] nums) {
        String[] strs = new String[nums.length];

        for (int i = 0; i < nums.length; i++) {
            strs[i] = Integer.toString(nums[i]);
        }

        Arrays.sort(strs, new Comparator<String>() {
            @Override
            public int compare(String s1, String s2) {
                if (s1.length() == s2.length()) {
                    return s2.compareTo(s1);
                }
                return (s2 + s1).compareTo(s1 + s2);
            }
        });

        if (strs[0].equals("0")) {
            return "0";
        }

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < strs.length; i++) {
            sb.append(strs[i]);
        }

        return sb.toString();
    }
}
