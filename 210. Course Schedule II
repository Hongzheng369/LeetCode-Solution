import java.util.*;

public class CourseScheduleII {
    // Method 1: adjacency list.
    /*
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        // Special case.
        if (numCourses == 0) {
            return new int[]{};
        }

        HashMap<Integer, HashSet<Integer>> succ = new HashMap<>();
        HashMap<Integer, Integer> inDegree = new HashMap<>();
        HashSet<Integer> courses = new HashSet<>();

        for (int i = 0; i < numCourses; i++) {
            courses.add(i);
        }

        for (int i = 0; i < prerequisites.length; i++) {
            if (!succ.containsKey(prerequisites[i][1])) {
                succ.put(prerequisites[i][1], new HashSet<>());
            }
            if (succ.get(prerequisites[i][1]).contains(prerequisites[i][0])) {
                continue;
            } else {
                succ.get(prerequisites[i][1]).add(prerequisites[i][0]);
            }

            inDegree.put(prerequisites[i][0], inDegree.getOrDefault(prerequisites[i][0], 0) + 1);
        }

        Queue<Integer> queue = new LinkedList<>();
        for (int course : courses) {
            if (!inDegree.containsKey(course)) {
                queue.add(course);
            }
        }

        ArrayList<Integer> list = new ArrayList<>();
        while (!queue.isEmpty()) {
            int course = queue.remove();
            list.add(course);

            if (succ.containsKey(course)) {
                for (int child : succ.get(course)) {
                    inDegree.put(child, inDegree.get(child) - 1);
                    if (inDegree.get(child) == 0) {
                        queue.add(child);
                    }
                }
            }
        }

        if (list.size() < numCourses) {
            return new int[]{};
        }

        int[] ans = new int[numCourses];
        for (int i = 0; i < numCourses; i++) {
            ans[i] = list.get(i);
        }

        return ans;
    }*/

    // Method 2: adjacency matrix.
    /*
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        // Special case.
        if (numCourses == 0) {
            return new int[]{};
        }

        int[][] matrix = new int[numCourses][numCourses];
        int[] inDegree = new int[numCourses];

        for (int i = 0; i < prerequisites.length; i++) {
            if (matrix[prerequisites[i][1]][prerequisites[i][0]] == 0) {
                matrix[prerequisites[i][1]][prerequisites[i][0]] = 1;
                inDegree[prerequisites[i][0]]++;
            }
        }

        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < numCourses; i++) {
            if (inDegree[i] == 0) {
                queue.add(i);
            }
        }

        ArrayList<Integer> list = new ArrayList<>();
        while (!queue.isEmpty()) {
            int course = queue.remove();
            list.add(course);

            for (int i = 0; i < numCourses; i++) {
                if (matrix[course][i] != 0 && --inDegree[i] == 0) {
                    queue.add(i);
                }
            }
        }

        if (list.size() < numCourses) {
            return new int[]{};
        }

        int[] ans = new int[numCourses];
        for (int i = 0; i < numCourses; i++) {
            ans[i] = list.get(i);
        }

        return ans;
    }*/

    // Method 3: DFS.
    int index = 0;

    public int[] findOrder(int numCourses, int[][] prerequisites) {
        // Special case.
        if (numCourses < 1) {
            return new int[0];
        }

        boolean[] visited = new boolean[numCourses];
        boolean[] currentRoute = new boolean[numCourses];
        List[] pre = new ArrayList[numCourses];
        int[] res = new int[numCourses];

        for (int i = 0; i < numCourses; i++) {
            pre[i] = new ArrayList<Integer>();
        }
        for (int[] p : prerequisites) {
            pre[p[0]].add(p[1]);
        }

        for (int i = 0; i < numCourses; i++) {
            if (dfs(visited, currentRoute, i, res, pre)) {
                return new int[0];
            }
        }

        return res;
    }

    private boolean dfs(boolean[] visited, boolean[] currentRoute, int start, int[] res, List[] pre) {
        if (visited[start]) {
            return false;
        }

        visited[start] = true;
        currentRoute[start] = true;

        for (int i = 0; i < pre[start].size(); i++) {
            int preCourse = (int)pre[start].get(i);
            if (currentRoute[preCourse] || dfs(visited, currentRoute, preCourse, res, pre)) {
                return true;
            }
        }

        currentRoute[start] = false;
        res[index++] = start;

        return false;
    }
}
