class Solution {
    /**
     * Method 1: use a new class and BFS to solve the problem.
     */
    /*
    class WordNode {
        String word;
        int step;

        public WordNode(String word, int step) {
            this.word = word;
            this.step = step;
        }
    }

    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        HashSet<String> dictionary = new HashSet<>(wordList);
        Queue<WordNode> queue = new LinkedList<>();
        queue.add(new WordNode(beginWord, 1));

        while (!queue.isEmpty()) {
            WordNode node = queue.remove();

            if (node.word.equals(endWord)) {
                return node.step;
            }

            char[] arr = node.word.toCharArray();
            for (int i = 0; i < arr.length; i++) {
                for (char c = 'a'; c <= 'z'; c++) {
                    if (arr[i] == c) {
                        continue;
                    }

                    char temp = arr[i];
                    arr[i] = c;

                    String newWord = new String(arr);
                    if (dictionary.contains(newWord)) {
                        queue.add(new WordNode(newWord, node.step + 1));
                        dictionary.remove(newWord);
                    }
                    
                    arr[i] = temp;
                }
            }
        }

        return 0;
    }
    */
    
    /**
     * Method 2: start BFS from both the head and the end.
     */
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        HashSet<String> dict = new HashSet<>(wordList);
        if (!dict.contains(endWord)) {
            return 0;
        }

        HashSet<String> startFromHead = new HashSet<>();
        HashSet<String> startFromEnd = new HashSet<>();
        startFromHead.add(beginWord);
        startFromEnd.add(endWord);

        int step = 0;
        int wordLength = beginWord.length();

        while (!startFromHead.isEmpty() && !startFromEnd.isEmpty()) {
            step++;
            if (startFromHead.size() > startFromEnd.size()) {
                HashSet<String> temp = startFromHead;
                startFromHead = startFromEnd;
                startFromEnd = temp;
            }

            HashSet<String> nextStep = new HashSet<>();

            for (String word : startFromHead) {
                char[] arr = word.toCharArray();

                for (int i = 0; i < wordLength; i++) {
                    char temp = arr[i];

                    for (char j = 'a'; j < 'z'; j++) {
                        if (temp == j) {
                            continue;
                        }

                        arr[i] = j;
                        String newWord = new String(arr);
                        if (startFromEnd.contains(newWord)) {
                            return step + 1;
                        }
                        if (!dict.contains(newWord)) {
                            continue;
                        }

                        dict.remove(newWord);
                        nextStep.add(newWord);
                    }

                    arr[i] = temp;
                }
            }

            startFromHead = nextStep;
        }

        return 0;
    }
}
