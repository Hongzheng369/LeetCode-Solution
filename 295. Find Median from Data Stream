/**
 * Method 1: my method.
 * During the insertion, decide where to insert the new number.
 * By doing this, this list is always sorted.
 * As for the time complexity, the insertion would be O(N * logN). The void function is O(1).
 */
 class MedianFinder {
    ArrayList<Integer> list;
    int size;
    
    
    /** initialize your data structure here. */
    public MedianFinder() {
        list = new ArrayList<>();
        size = 0;
    }
    
    public void addNum(int num) {
        list.add(findIndex(list, num), num);
        size++;
    }
    
    public double findMedian() {
        if ((size & 1) == 1) {
            return (double)(list.get(size / 2));
        } else {
            double first = (double)(list.get(size / 2 - 1));
            double second = (double)(list.get(size / 2));
            return (first + second) / 2;
        }
    }
    
    private int findIndex(ArrayList<Integer> list, int target) {
        if (list == null || list.size() == 0) {
            return 0;
        }

        int left = 0, right = list.size();

        while (left < right) {
            int mid = left + (right - left) / 2;
            if (list.get(mid) == target) {
                return mid;
            } else if (list.get(mid) > target) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }

        return left;
    }
}

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder obj = new MedianFinder();
 * obj.addNum(num);
 * double param_2 = obj.findMedian();
 */
 
 
 
 
/**
 * Method 2: using two heap.
 * During the insertion, decide where to insert the new number, the first part or the second part.
 * No need to sort them all, all I need to know is the largest in the first part and the smallest in the second part.
 * As for the time complexity, the insertion would be O(N * logN). The void function is O(1).
 */
 class MedianFinder {
    PriorityQueue<Integer> firstHalf, secondHalf;
    int size1, size2;

    /** initialize your data structure here. */
    public MedianFinder() {
        firstHalf = new PriorityQueue<>(new Comparator<Integer>(){
            public int compare(Integer o1, Integer o2) {
                return o2 - o1;
            }
        });
        secondHalf = new PriorityQueue<>();
        size1 = 0;
        size2 = 0;
    }
    
    public void addNum(int num) {
        if (size1 == 0) {
            firstHalf.add(num);
            size1++;
        } else {
            if (size1 == size2) {
                if (num > secondHalf.peek()) {
                    firstHalf.add(secondHalf.remove());
                    secondHalf.add(num);
                } else {
                    firstHalf.add(num);
                }
                size1++;
            } else {
                if (num > firstHalf.peek()) {
                    secondHalf.add(num);
                } else {
                    secondHalf.add(firstHalf.remove());
                    firstHalf.add(num);
                }
                size2++;
            }
        }
    }
    
    public double findMedian() {
        if (size1 == size2) {
            return ((double)(firstHalf.peek()) + (double)(secondHalf.peek())) / 2;
        } else {
            return (double)(firstHalf.peek());
        }
    }
}

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder obj = new MedianFinder();
 * obj.addNum(num);
 * double param_2 = obj.findMedian();
 */
