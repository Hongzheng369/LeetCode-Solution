/**
 * Method 1: my method.
 * During the insertion, decide where to insert the new number.
 * By doing this, this list is always sorted.
 * As for the time complexity, the insertion would be O(N * logN). The void function is O(1).
 */
 class MedianFinder {
    ArrayList<Integer> list;
    int size;
    
    
    /** initialize your data structure here. */
    public MedianFinder() {
        list = new ArrayList<>();
        size = 0;
    }
    
    public void addNum(int num) {
        list.add(findIndex(list, num), num);
        size++;
    }
    
    public double findMedian() {
        if ((size & 1) == 1) {
            return (double)(list.get(size / 2));
        } else {
            double first = (double)(list.get(size / 2 - 1));
            double second = (double)(list.get(size / 2));
            return (first + second) / 2;
        }
    }
    
    private int findIndex(ArrayList<Integer> list, int target) {
        if (list == null || list.size() == 0) {
            return 0;
        }

        int left = 0, right = list.size();

        while (left < right) {
            int mid = left + (right - left) / 2;
            if (list.get(mid) == target) {
                return mid;
            } else if (list.get(mid) > target) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }

        return left;
    }
}

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder obj = new MedianFinder();
 * obj.addNum(num);
 * double param_2 = obj.findMedian();
 */
 
 
 
 
