class Solution {
    // Method 1: brute force.
    /*
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        if (nums.length == 0){
            return res;
        }
        else if (nums.length == 1){
            List<Integer> tmp = new ArrayList<>();
            tmp.add(nums[0]);
            res.add(tmp);
        }
        else{
            Queue<List<Integer>> queue = new LinkedList<>();
            
            for (int i : nums){
                List<Integer> tmp = new ArrayList<>();
                tmp.add(i);
                queue.add(tmp);
            }
            
            for (int i = 0; i < nums.length - 1; i++){
                int size = queue.size();
                
                for (int j = 0; j < size; j++){
                    List<Integer> tra = queue.remove();
                    
                    for (int k : nums){
                        if (!tra.contains(k)){
                            List<Integer> tmp = new ArrayList<>(tra);
                            tmp.add(k);
                            queue.add(tmp);
                        }
                    }
                }
            }
            
            while (!queue.isEmpty()) {
                res.add(queue.remove());
            }
        }
        return res;
    }*/
    
    // Method 2: backtracking.
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        List<Integer> list = new ArrayList<>();
        for (int num : nums) {
            list.add(num);
        }
        
        backtracking(nums.length, 0, ans, list);
        
        return ans;
    }
    
    private void backtracking(int len, int first, List<List<Integer>> ans, List<Integer> list) {
        if (first == len) {
            ans.add(new ArrayList<>(list));
            return;
        }
        
        for (int i = first; i < len; i++) {
            Collections.swap(list, first, i);
            backtracking(len, first + 1, ans, list);
            Collections.swap(list, first, i);
        }
        return;
    }
}
