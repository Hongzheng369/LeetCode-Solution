class MaxStack {
    // Method 1: using PriorityQueue and Deque.
    /*
    PriorityQueue<Integer> maxHeap;
    Deque<Integer> stack;
    
    public MaxStack() {
        maxHeap = new PriorityQueue<>(new Comparator<Integer>(){
            public int compare(Integer o1, Integer o2) {
                return o2 - o1;
            }
        });
        stack = new LinkedList<>();
    }
    
    public void push(int x) {
        maxHeap.add(x);
        stack.addFirst(x);
    }
    
    public int pop() {
        int temp = stack.removeFirst();
        maxHeap.remove(temp);
        return temp;
    }
    
    public int top() {
        return stack.peekFirst();
    }
    
    public int peekMax() {
        return maxHeap.peek();
    }
    
    public int popMax() {
        int temp = maxHeap.remove();
        stack.remove(temp);
        return temp;
    }*/
    
    // Method 2:
    class Node {
        int val;
        Node prev;
        Node next;
        Node smaller;
        Node larger;
        Node(int x) {
            val = x;
        }
    }
    
    Node head;
    Node maxHead;
    
    public MaxStack() {
        head = null;
        maxHead = null;
    }
    
    public void push(int x) {
        Node curr = new Node(x);
        if (head == null) {
            head = curr;
        } else {
            curr.next = head;
            head.prev = curr;
            head = curr;
        }
        
        Node smallerNode = maxHead;
        Node largerNode = null;
        while (smallerNode != null && smallerNode.val > curr.val) {
            largerNode = smallerNode;
            smallerNode = smallerNode.smaller;
        }
        
        if (largerNode == null) {
            curr.smaller = maxHead;
            if (maxHead != null) {
                maxHead.larger = curr;
            }
            maxHead = curr;
        } else {
            largerNode.smaller = curr;
            curr.larger = largerNode;
            curr.smaller = smallerNode;
            if (smallerNode != null) {
                smallerNode.larger = curr;
            }
        }
    }
    
    public int pop() {
        Node curr = head;
        head = head.next;
        if (head != null) {
            head.prev = null;
        }
        
        Node smallerNode = curr.smaller;
        Node largerNode = curr.larger;
        if (largerNode == null) {
            maxHead = smallerNode;
            if (smallerNode != null) {
                smallerNode.larger = null;
            }
        } else if (smallerNode == null) {
            largerNode.smaller = null;
        } else {
            smallerNode.larger = largerNode;
            largerNode.smaller = smallerNode;
        }
        
        return curr.val;
    }
    
    public int top() {
        return head.val;
    }
    
    public int peekMax() {
        return maxHead.val;
    }
    
    public int popMax() {
        Node curr = maxHead;
        maxHead = maxHead.smaller;
        if (maxHead != null) {
            maxHead.larger = null;
        }
        
        Node prevNode = curr.prev;
        Node nextNode = curr.next;
        
        if (prevNode == null) {
            head = nextNode;
            if (nextNode != null) {
                nextNode.prev = null;
            }
        } else if (nextNode == null) {
            prevNode.next = null;
        } else {
            prevNode.next = nextNode;
            nextNode.prev = prevNode;
        }
        
        return curr.val;
    }
}

/**
 * Your MaxStack object will be instantiated and called as such:
 * MaxStack obj = new MaxStack();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.peekMax();
 * int param_5 = obj.popMax();
 */
