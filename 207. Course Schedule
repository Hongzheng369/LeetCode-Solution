class Solution {
    // Method 1: use adjacency list.
    /*
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        // Special case.
        if (numCourses == 0 || prerequisites == null) {
            return true;
        }
        
        // Build a graph.
        HashMap<Integer, HashSet<Integer>> succ = new HashMap<>();
        HashMap<Integer, Integer> inDegree = new HashMap<>();
        HashSet<Integer> courses = new HashSet<>();
        int len = prerequisites.length;
        
        for (int i = 0; i < len; i++) {
            // Update "courses".
            courses.add(prerequisites[i][0]);
            courses.add(prerequisites[i][1]);
            
            // Update "succ".
            if (!succ.containsKey(prerequisites[i][1])) {
                succ.put(prerequisites[i][1], new HashSet<>());
            }
            
            if (succ.get(prerequisites[i][1]).contains(prerequisites[i][0])) {
                continue;
            } else {
                succ.get(prerequisites[i][1]).add(prerequisites[i][0]);
            }
                
            // Update "inDegree".
            inDegree.put(prerequisites[i][0], inDegree.getOrDefault(prerequisites[i][0], 0) + 1);
        }
        
        // Topological sort.
        Queue<Integer> queue = new LinkedList<>();
        for (int course : courses) {
            if (!inDegree.containsKey(course)) {
                queue.add(course);
            }
        }
        
        while (!queue.isEmpty()) {
            int course = queue.remove();
            courses.remove(course);
            
            if (succ.containsKey(course)) {
                for (int child : succ.get(course)) {
                    inDegree.put(child, inDegree.get(child) - 1);
                    
                    if (inDegree.get(child) == 0) {
                        queue.add(child);
                    }
                }
            }
        }
        
        // If "courses" has something left, return false.
        return courses.size() == 0;
    }*/
    
    // Method 2: use adjacency matrix.
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        if (numCourses == 0 || prerequisites == null) {
            return true;
        }
        
        int[][] matrix = new int[numCourses][numCourses];
        int[] inDegree = new int[numCourses];
        
        for (int i = 0; i < prerequisites.length; i++) {
            if (matrix[prerequisites[i][1]][prerequisites[i][0]] == 0) {
                matrix[prerequisites[i][1]][prerequisites[i][0]] = 1;
                inDegree[prerequisites[i][0]]++;
            }
        }
        
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < numCourses; i++) {
            if (inDegree[i] == 0) {
                queue.add(i);
            }
        }
        
        int count = 0;
        while (!queue.isEmpty()) {
            int course = queue.remove();
            count++;
            
            for (int i = 0; i < numCourses; i++) {
                if (matrix[course][i] != 0 && --inDegree[i] == 0) {
                    queue.add(i);
                }
            }
        }
        
        return count == numCourses;
    }
}
